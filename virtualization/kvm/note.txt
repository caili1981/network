kvm与xen的区别：
1.  xen是作为一个单独的用户程序运行的。宿主机只是运行在xen-vmm上的一个特殊操作系统. 而kvm只是linux下的一个内核模块。它和宿主机是一体的。
个人理解：
xen的抽象程度其实是非常高的，但是他需要实现硬件管理，调度的功能。以至于xen的实现复杂，而且很难得到linux社区的支持，而xen则是理想主义。
kvm的抽象程度不如xen，但是他却可以利用linux操作系统的绝大部分功能,如硬件管理，驱动，调度，等等。 kvm是实用主义。

kvm是一个动态可加载的内核模块，运行在host上，分为内核无关模块和内核相关模块. kvm以及kvm－intel。
kvm内核模块在动态加载时，会打开cpu的虚拟化功能，将客户机置于虚拟化模式下运行。

qemu作为一个硬件模拟器，提供硬件模拟，如磁盘，显示器等等，通过ioctl和kvm进行通信。

/dev/kvm这个文件，它是kvm内核模块提供给用户空间的qemu-kvm程序使用的一个控制接口。
比如创建虚拟化接口，一般kvm就会为此虚拟机创建响应的内存数据结构。

虚拟化一般需要分为三个主要部分：cpu虚拟化，内存虚拟化，和io虚拟化。
cpu虚拟化，可以分为指令翻译（vmware主要采用这种技术），和陷入再处理。指令翻译技术性能比较差。而陷入再处理技术，会因为部分敏感指令无法被中断捕获而难以执行。intel的vt－x技术主要是为了解决某些中断指令无法被捕获。通过增加vm－entry和wm－exit事件，再vm－entry时，系统运行在虚拟机下，所有敏感指令此时都可以被捕获。
内存虚拟化技术，刚开始一般通过影子页表解决，再intel的支持下，通过ept，扩展二级页表，可以很简单的实现guest－虚拟内存地址到host－物理内存地址的转换。
io虚拟化，刚开始一般通过模拟器解决。模拟器解决的主要缺陷是性能底下，同时不支持dma映射。intel的vt－d技术，可以捕获dma指令，将guest物理地址转换成host的物理地址。


而kvm中的一个客户机是作为一个用户空间进程qemu-kvm运行的
kvm可以为每个虚拟机虚拟出一系列的vcpu组，同时可以为vcpu绑定线程亲和性，这样子linux可以以更高效率的方式进行调度。
暂时看到75页。


linux下挂载新磁盘的命令：
https://zhidao.baidu.com/question/157111059.html

