# 内核线程和普通线程.
  1.  内核线程
      内核线程是操作系统调度的基本单位。一个应用程序，可以看成一个内核线程，这就意味着一个应用程序内，只会有一个线程同时调用。需要内核支持。 
      调度需要内核态的转换，开销比较大。
      scope:PTHREAD_SCOPE_SYSTEM 这个attribute可以用来确定多线程是内核线程.
      
  2.  用户线程.
      如上。
      
# 多线程模型:
  1.  pipe-line
      pipe-line模式能够有效避免锁的开销，但是pipe-line模式的cpu负载均衡很难，从而制约了cpu的利用率。
  2.  run-to-finished.
      锁开销比较大，但是cpu的利用率会比较高.
      
# 多线程同步技术
  1.  rwlock
      一个控制路径（写)和转发路径(读)上经常用. 路由器／防火墙的配置经常会用到rwlock
  2.  spinlock
      对同一个变量进行访问和修改. 多用于转发路径上.
  3.  seqlock
      意义不大，仅仅是不block读进程而已. 当读结束时，有可能需要重新操作，这点并不友好。
  4.  rcu/deffer-delete
      用在访问指针时，指针在rcu／deffer－delete指定的时间段之后肯定不会再使用。比如删除一条路由器／防火墙上的配置，但是rt转发端仍然有可能保存这个指针。
      deffer-delete就是意味着在等待指针肯定不存在于转发路径上时，删除。
  5.  mutex 
      大块任务。没有获得mutex的线程会立即sleep。一般用在普通的程序中，而不是转发路径上。
  6.  信号量
      进程之间的互斥。
    
      
